<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map App</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        * {
            box-sizing: border-box;
        }

        #root {
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        #map {
            height: 600px;
            width: 100%;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <header>

    </header>
    <main id="root">
        <section>
            <div id="controls">
                <h4>Enter Coordinates</h4>
                <label for="source">Source (lat,lng):</label>
                <input type="text" id="source" placeholder="37.7749,-122.4194"><br>
                <label for="destination">Destination (lat,lng):</label>
                <input type="text" id="destination" placeholder="37.7750,-122.4183"><br>
                <button onclick="findPath()">Find Shortest Path</button>
            </div>
            <div id="map"></div>
        </section>
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <script>
            /**
             * Constants
             */
            const centerCoordinates = { lat: 38.6251, lng: -90.1868 };
            let map;

            /**
             * Initialize Google Map
             */
            function initMap() {
                map = new google.maps.Map(document.getElementById("map"), {
                    center: centerCoordinates,
                    zoom: 15,
                    mapTypeId: "roadmap"
                });
            }

            /**
             * Fetch OSM data
             */
            async function fetchStreetData() {
                const query = `
                    [out:json];
                    way["highway"](around:1000, ${centerCoordinates.lat}, ${centerCoordinates.lng});
                    (._;>;);
                    out body;
                `;

                const res = await fetch(
                    "https://overpass-api.de/api/interpreter?data=" +
                    encodeURIComponent(query)
                );

                return res.json();
            }

            /**
             * Build graph
             */
            function buildGraph(data) {
                const graph = {};
                const nodeCoords = {};

                data.elements.forEach(el => {
                    if (el.type === "node") {
                        nodeCoords[el.id] = { lat: el.lat, lng: el.lon };
                    }
                });

                data.elements.forEach(el => {
                    if (el.type === "way" && el.nodes) {
                        for (let i = 0; i < el.nodes.length - 1; i++) {
                            const a = el.nodes[i];
                            const b = el.nodes[i + 1];

                            if (!nodeCoords[a] || !nodeCoords[b]) continue;

                            graph[a] ??= {};
                            graph[b] ??= {};

                            graph[a][b] = 1;
                            graph[b][a] = 1;
                        }
                    }
                });

                return { graph, nodeCoords };
            }

            /**
             * Nearest node lookup
             */
            function findNearestNode(lat, lng, nodeCoords) {
                let nearest = null;
                let minDist = Infinity;

                for (const id in nodeCoords) {
                    const n = nodeCoords[id];
                    const d =
                        Math.pow(lat - n.lat, 2) +
                        Math.pow(lng - n.lng, 2);

                    if (d < minDist) {
                        minDist = d;
                        nearest = id;
                    }
                }

                return nearest;
            }

            /**
             * Dijkstra
             */
            function dijkstra(graph, start, end) {
                const dist = {};
                const prev = {};
                const q = new Set(Object.keys(graph));

                for (const v of q) {
                    dist[v] = Infinity;
                    prev[v] = null;
                }

                dist[start] = 0;

                while (q.size) {
                    let u = null;
                    for (const v of q) {
                        if (u === null || dist[v] < dist[u]) u = v;
                    }

                    if (dist[u] === Infinity) break;
                    if (u === end) break;

                    q.delete(u);

                    for (const n in graph[u]) {
                        const alt = dist[u] + graph[u][n];
                        if (alt < dist[n]) {
                            dist[n] = alt;
                            prev[n] = u;
                        }
                    }
                }

                const path = [];
                let cur = end;
                while (cur) {
                    path.push(cur);
                    cur = prev[cur];
                }

                return path.length ? path.reverse() : null;
            }

            /**
             * Draw route
             */
            function visualizeRoute(path, nodeCoords) {
                if (!path || path.length < 2) {
                    alert("No route found");
                    return;
                }

                const coords = path
                    .map(id => nodeCoords[id])
                    .filter(c => c && isFinite(c.lat) && isFinite(c.lng));

                if (coords.length < 2) {
                    alert("Route geometry invalid");
                    return;
                }

                const polyline = new google.maps.Polyline({
                    path: coords,
                    map: map,
                    strokeWeight: 5
                });

                const bounds = new google.maps.LatLngBounds();
                coords.forEach(c => bounds.extend(c));

                map.fitBounds(bounds);

                console.log("Route points:", coords.length);
            }

            /**
             * Main
             */
            async function findPath() {
                const s = document.getElementById("source").value.split(",");
                const d = document.getElementById("destination").value.split(",");

                const source = { lat: parseFloat(s[0]), lng: parseFloat(s[1]) };
                const dest = { lat: parseFloat(d[0]), lng: parseFloat(d[1]) };

                const data = await fetchStreetData();
                const { graph, nodeCoords } = buildGraph(data);

                const start = findNearestNode(source.lat, source.lng, nodeCoords);
                const end = findNearestNode(dest.lat, dest.lng, nodeCoords);

                if (!start || !end) {
                    alert("No nearby road nodes found");
                    return;
                }

                const path = dijkstra(graph, start, end);
                visualizeRoute(path, nodeCoords);
            }
        </script>
        <script
            async
            defer
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBQlrZtfXXjfw6D-wDmNIAOxEV20V5E2U8&callback=initMap">
        </script>

        <footer>

        </footer>
    </main>
</body>
</html>
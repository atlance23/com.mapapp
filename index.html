<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map App</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        * {
            box-sizing: border-box;
        }

        #root {
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        #map {
            height: 600px;
            width: 100%;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <header>

    </header>
    <main id="root">
        <section>
            <div id="controls">
                <h4>Enter Coordinates</h4>
                <label for="source">Source (lat,lng):</label>
                <input type="text" id="source" placeholder="37.7749,-122.4194"><br>
                <label for="destination">Destination (lat,lng):</label>
                <input type="text" id="destination" placeholder="37.7750,-122.4183"><br>
                <button onclick="findPath()">Find Shortest Path</button>
            </div>
            <div id="map"></div>
        </section>
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <script>
            /**
             * Constants
             */
            const centerCoordinates = { lat: 38.6251, lng: -90.1868 };
            let map;

            /**
             * Initialize Google Map
             */
            function initMap() {
                map = new google.maps.Map(document.getElementById("map"), {
                    center: centerCoordinates,
                    zoom: 15,
                    mapTypeId: "roadmap"
                });
            }

            /**
             * Fetch OSM data
             */
            async function fetchStreetData() {
                const query = `
                    [out:json];
                    way["highway"](around:1000, ${centerCoordinates.lat}, ${centerCoordinates.lng});
                    (._;>;);
                    out body;
                `;

                const res = await fetch(
                    "https://overpass-api.de/api/interpreter?data=" +
                    encodeURIComponent(query)
                );

                return res.json();
            }

            /**
             * Build graph
             */
            function buildGraph(data) {
                const graph = {};
                const nodeCoords = {};

                data.elements.forEach(el => {
                    if (el.type === "node") {
                        nodeCoords[el.id] = { lat: el.lat, lng: el.lon };
                    }
                });

                data.elements.forEach(el => {
                    if (el.type === "way" && el.nodes) {
                        for (let i = 0; i < el.nodes.length - 1; i++) {
                            const a = el.nodes[i];
                            const b = el.nodes[i + 1];

                            if (!nodeCoords[a] || !nodeCoords[b]) continue;

                            graph[a] ??= {};
                            graph[b] ??= {};

                            graph[a][b] = 1;
                            graph[b][a] = 1;
                        }
                    }
                });

                return { graph, nodeCoords };
            }

            /**
             * Nearest node lookup
             */
            function findNearestNode(lat, lng, nodeCoords) {
                let nearest = null;
                let minDist = Infinity;

                for (const id in nodeCoords) {
                    const n = nodeCoords[id];
                    const d =
                        Math.pow(lat - n.lat, 2) +
                        Math.pow(lng - n.lng, 2);

                    if (d < minDist) {
                        minDist = d;
                        nearest = id;
                    }
                }

                return nearest;
            }

            /**
             * Distance & heuristic helpers
             */

            function haversine(a, b) {
                const R = 6371000; // meters
                const toRad = x => x * Math.PI / 180;

                const dLat = toRad(b.lat - a.lat);
                const dLng = toRad(b.lng - a.lng);

                const lat1 = toRad(a.lat);
                const lat2 = toRad(b.lat);

                const h =
                    Math.sin(dLat / 2) ** 2 +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(dLng / 2) ** 2;

                return 2 * R * Math.asin(Math.sqrt(h));
            }


            /**
             * A* function
             */
            function aStar(graph, nodeCoords, start, goal) {
                const openSet = new Set([start]);
                const cameFrom = {};

                const gScore = {};
                const fScore = {};

                for (const v in graph) {
                    gScore[v] = Infinity;
                    fScore[v] = Infinity;
                }

                gScore[start] = 0;
                fScore[start] = haversine(
                    nodeCoords[start],
                    nodeCoords[goal]
                );

                while (openSet.size) {
                    let current = null;

                    for (const v of openSet) {
                        if (current === null || fScore[v] < fScore[current]) {
                            current = v;
                        }
                    }

                    if (current === goal) {
                        const path = [];
                        let c = current;
                        while (c) {
                            path.push(c);
                            c = cameFrom[c];
                        }
                        return path.reverse();
                    }

                    openSet.delete(current);

                    for (const neighbor in graph[current]) {
                        const tentativeG =
                            gScore[current] +
                            haversine(
                                nodeCoords[current],
                                nodeCoords[neighbor]
                            );

                        if (tentativeG < gScore[neighbor]) {
                            cameFrom[neighbor] = current;
                            gScore[neighbor] = tentativeG;
                            fScore[neighbor] =
                                tentativeG +
                                haversine(
                                    nodeCoords[neighbor],
                                    nodeCoords[goal]
                                );

                            openSet.add(neighbor);
                        }
                    }
                }

                return null;
            }

            /**
             * Draw route
             */
            function visualizeRoute(path, nodeCoords) {
                if (!path || path.length < 2) {
                    alert("No route found");
                    return;
                }

                const coords = path
                    .map(id => nodeCoords[id])
                    .filter(c => c && isFinite(c.lat) && isFinite(c.lng));

                if (coords.length < 2) {
                    alert("Route geometry invalid");
                    return;
                }

                const polyline = new google.maps.Polyline({
                    path: coords,
                    map: map,
                    strokeWeight: 5
                });

                const bounds = new google.maps.LatLngBounds();
                coords.forEach(c => bounds.extend(c));

                map.fitBounds(bounds);

                console.log("Path length:", path?.length);
            }

            /**
             * Main
             */
            async function findPath() {
                const s = document.getElementById("source").value.split(",");
                const d = document.getElementById("destination").value.split(",");

                const source = { lat: parseFloat(s[0]), lng: parseFloat(s[1]) };
                const dest = { lat: parseFloat(d[0]), lng: parseFloat(d[1]) };

                const data = await fetchStreetData();
                const { graph, nodeCoords } = buildGraph(data);

                const start = findNearestNode(source.lat, source.lng, nodeCoords);
                const end = findNearestNode(dest.lat, dest.lng, nodeCoords);

                if (!start || !end) {
                    alert("No nearby road nodes found");
                    return;
                }

                const path = aStar(graph, nodeCoords, start, end);
                visualizeRoute(path, nodeCoords);
            }
        </script>
        <script
            async
            defer
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBQlrZtfXXjfw6D-wDmNIAOxEV20V5E2U8&callback=initMap">
        </script>

        <footer>

        </footer>
    </main>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map App</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        * {
            box-sizing: border-box;
        }

        #root {
            width: 100vw;
            max-width: 100vw;
            height: 100vh;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        #map {
            height: 600px;
            width: 100%;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <header>

    </header>
    <main id="root">
        <section>
            <div id="controls">
                <h4>Enter Coordinates</h4>
                <label for="source">Source (lat,lng):</label>
                <input type="text" id="source" placeholder="37.7749,-122.4194"><br>
                <label for="destination">Destination (lat,lng):</label>
                <input type="text" id="destination" placeholder="37.7750,-122.4183"><br>
                <button onclick="findPath()">Find Shortest Path</button>
            </div>
            <div id="map"></div>
        </section>
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <script>
            /**
             * Constants
             */
            const centerCoordinates = { lat: 38.6251, lng: -90.1868 }; // St. Louis area

            /**
             * Initialize Map
             */
            const map = L.map('map').setView(
                [centerCoordinates.lat, centerCoordinates.lng],
                15
            );

            // Proper tile layer (Leaflet-compatible)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            /**
             * Fetch OSM data (nodes + ways)
             */
            async function fetchStreetData() {
                const query = `
                    [out:json];
                    (
                        node(around:1000, ${centerCoordinates.lat}, ${centerCoordinates.lng});
                        way["highway"](around:1000, ${centerCoordinates.lat}, ${centerCoordinates.lng});
                    );
                    out body;
                `;

                const response = await fetch(
                    'https://overpass-api.de/api/interpreter?data=' +
                    encodeURIComponent(query)
                );
                return response.json();
            }

            /**
             * Build graph + node coordinate lookup
             */
            function buildGraph(data) {
                const graph = {};
                const nodeCoords = {};

                // Store node coordinates
                data.elements.forEach(el => {
                    if (el.type === 'node') {
                        nodeCoords[el.id] = [el.lat, el.lon];
                    }
                });

                // Build graph from ways
                data.elements.forEach(el => {
                    if (el.type === 'way' && el.nodes) {
                        for (let i = 0; i < el.nodes.length - 1; i++) {
                            const from = el.nodes[i];
                            const to = el.nodes[i + 1];

                            if (!nodeCoords[from] || !nodeCoords[to]) continue;

                            if (!graph[from]) graph[from] = {};
                            if (!graph[to]) graph[to] = {};

                            graph[from][to] = 1;
                            graph[to][from] = 1;
                        }
                    }
                });

                return { graph, nodeCoords };
            }

            /**
             * Find nearest graph node to lat/lng
             */
            function findNearestNode(lat, lng, nodeCoords) {
                let nearest = null;
                let minDist = Infinity;

                for (const id in nodeCoords) {
                    const [nLat, nLng] = nodeCoords[id];
                    const d =
                        Math.pow(lat - nLat, 2) +
                        Math.pow(lng - nLng, 2);

                    if (d < minDist) {
                        minDist = d;
                        nearest = id;
                    }
                }

                return nearest;
            }

            /**
             * Dijkstra
             */
            function dijkstra(graph, start, end) {
                const distances = {};
                const previous = {};
                const queue = new Set(Object.keys(graph));

                for (const v of queue) {
                    distances[v] = Infinity;
                    previous[v] = null;
                }

                distances[start] = 0;

                while (queue.size) {
                    let current = null;

                    for (const v of queue) {
                        if (current === null || distances[v] < distances[current]) {
                            current = v;
                        }
                    }

                    if (distances[current] === Infinity) break;
                    if (current === end) break;

                    queue.delete(current);

                    for (const neighbor in graph[current]) {
                        const alt = distances[current] + graph[current][neighbor];
                        if (alt < distances[neighbor]) {
                            distances[neighbor] = alt;
                            previous[neighbor] = current;
                        }
                    }
                }

                const path = [];
                let cur = end;

                while (cur) {
                    path.push(cur);
                    cur = previous[cur];
                }

                return path.length ? path.reverse() : null;
            }

            /**
             * Draw route
             */
            function visualizeRoute(path, nodeCoords) {
                if (!path) {
                    alert('No route found');
                    return;
                }

                const coords = path.map(id => nodeCoords[id]);
                const polyline = L.polyline(coords, { weight: 5 }).addTo(map);
                map.fitBounds(polyline.getBounds());
            }

            /**
             * Main entry
             */
            async function findPath() {
                const sourceInput = document.getElementById('source').value.split(',');
                const destInput = document.getElementById('destination').value.split(',');

                const source = {
                    lat: parseFloat(sourceInput[0]),
                    lng: parseFloat(sourceInput[1])
                };

                const dest = {
                    lat: parseFloat(destInput[0]),
                    lng: parseFloat(destInput[1])
                };

                const data = await fetchStreetData();
                const { graph, nodeCoords } = buildGraph(data);

                const startNode = findNearestNode(source.lat, source.lng, nodeCoords);
                const endNode = findNearestNode(dest.lat, dest.lng, nodeCoords);

                if (!startNode || !endNode) {
                    alert('Could not find nearby roads');
                    return;
                }

                const path = dijkstra(graph, startNode, endNode);
                visualizeRoute(path, nodeCoords);
            }
        </script>
        <footer>

        </footer>
    </main>
</body>
</html>